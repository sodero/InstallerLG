%{
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* lexer.l:                                                                                                                                                                             */
/*                                                                                                                                                                                      */
/* InstallerLG tokenizer                                                                                                                                                                */
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* Copyright (C) 2018-2023, Ola Söder. All rights reserved.                                                                                                                             */
/* Licensed under the AROS PUBLIC LICENSE (APL) Version 1.1                                                                                                                             */
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

#include "args.h"
#include "error.h"
#include "parser.h"
#include "types.h"
#include "util.h"
#include "resource.h"
#include "lexer.h"

#include <stdlib.h>

/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
// We don't want scan-build warnings from code generated by Flex.
#ifndef __clang_analyzer__
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

static FILE *script;

/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* strduptr(const char *str) - Duplicate string and translate escape characters according to the Installer V42.6 guide                                                                  */
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
static char *strduptr(const char *str);
%}
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
    /* We need the parser to be reentrant, not because we want to, but because it will leak memory otherwise.                                                                      */
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
%option noyywrap reentrant bison-bridge caseless
%x comment

%%
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
    /* Decimal numbers                                                                                                                                                                  */
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
-?[0-9]+(\.?[0-9]+)?    {
    yylval->n = (int32_t) strtoul(yytext, NULL, 10);
    return INT;
}

    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
    /* Hexadecimal numbers                                                                                                                                                              */
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
\$[0-9a-fA-F]+          {
    yylval->n = (int32_t) strtoul(yytext + 1, NULL, 16);
    return HEX;
}

    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
    /* Binary numbers                                                                                                                                                                   */
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
%[01]+                  {
    yylval->n = (int32_t) strtoul(yytext + 1, NULL, 2);
    return BIN;
}

    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
    /* Syntactic markers                                                                                                                                                                */
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
"("                     { return '(';            }
")"                     { return ')';            }

    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
    /* Built-in functions and options                                                                                                                                                   */
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
"="                     { return '=';            }
"<"                     { return '<';            }
"<="                    { return LTE;            }
">"                     { return '>';            }
">="                    { return GTE;            }
"<>"                    { return NEQ;            }
"+"                     { return '+';            }
"-"                     { return '-';            }
"*"                     { return '*';            }
"/"                     { return '/';            }
"abort"                 { return ABORT;          }
"all"                   { return ALL;            }
"and"                   { return AND;            }
"append"                { return APPEND;         }
"askbool"               { return ASKBOOL;        }
"askchoice"             { return ASKCHOICE;      }
"askdir"                { return ASKDIR;         }
"askdisk"               { return ASKDISK;        }
"askfile"               { return ASKFILE;        }
"asknumber"             { return ASKNUMBER;      }
"askoptions"            { return ASKOPTIONS;     }
"askstring"             { return ASKSTRING;      }
"assigns"               { return ASSIGNS;        }
"back"                  { return BACK;           }
"bitand"                { return BITAND;         }
"bitnot"                { return BITNOT;         }
"bitor"                 { return BITOR;          }
"bitxor"                { return BITXOR;         }
"cat"                   { return CAT;            }
"choices"               { return CHOICES;        }
"closemedia"            { return CLOSEMEDIA;     }
"closewbobject"         { return CLOSEWBOBJECT;  }
"command"               { return COMMAND;        }
"compression"           { return COMPRESSION;    }
"complete"              { return COMPLETE;       }
"confirm"               { return CONFIRM;        }
"copyfiles"             { return COPYFILES;      }
"copylib"               { return COPYLIB;        }
"database"              { return DATABASE;       }
"debug"                 { return DEBUG;          }
"default"               { return DEFAULT;        }
"delete"                { return DELETE;         }
"delopts"               { return DELOPTS;        }
"dest"                  { return DEST;           }
"disk"                  { return DISK;           }
"earlier"               { return EARLIER;        }
"effect"                { return EFFECT;         }
"execute"               { return EXECUTE;        }
"exists"                { return EXISTS;         }
"exit"                  { return EXIT;           }
"expandpath"            { return EXPANDPATH;     }
"fileonly"              { return FILEONLY;       }
"files"                 { return FILES;          }
"fonts"                 { return FONTS;          }
"foreach"               { return FOREACH;        }
"getassign"             { return GETASSIGN;      }
"getdefaulttool"        { return GETDEFAULTTOOL; }
"getdevice"             { return GETDEVICE;      }
"getdiskspace"          { return GETDISKSPACE;   }
"getenv"                { return GETENV;         }
"getposition"           { return GETPOSITION;    }
"getstack"              { return GETSTACK;       }
"getsize"               { return GETSIZE;        }
"getsum"                { return GETSUM;         }
"gettooltype"           { return GETTOOLTYPE;    }
"getversion"            { return GETVERSION;     }
"help"                  { return HELP;           }
"iconinfo"              { return ICONINFO;       }
"if"                    { return IF;             }
"in"                    { return IN;             }
"include"               { return INCLUDE;        }
"infos"                 { return INFOS;          }
"makeassign"            { return MAKEASSIGN;     }
"makedir"               { return MAKEDIR;        }
"message"               { return MESSAGE;        }
"newname"               { return NEWNAME;        }
"newpath"               { return NEWPATH;        }
"nogauge"               { return NOGAUGE;        }
"noposition"            { return NOPOSITION;     }
"noreq"                 { return NOREQ;          }
"not"                   { return NOT;            }
"onerror"               { return ONERROR;        }
"openwbobject"          { return OPENWBOBJECT;   }
"optional"              { return OPTIONAL;       }
"override"              { return OVERRIDE;       }
"or"                    { return OR;             }
"pathonly"              { return PATHONLY;       }
"patmatch"              { return PATMATCH;       }
"pattern"               { return PATTERN;        }
"procedure"             { return DCL;            }
"prompt"                { return PROMPT;         }
"protect"               { return PROTECT;        }
"querydisplay"          { return QUERYDISPLAY;   }
"quiet"                 { return QUIET;          }
"range"                 { return RANGE;          }
"reboot"                { return REBOOT;         }
"rename"                { return RENAME;         }
"resident"              { return RESIDENT;       }
"retrace"               { return RETRACE;        }
"rexx"                  { return REXX;           }
"run"                   { return RUN;            }
"safe"                  { return SAFE;           }
"select"                { return SELECT;         }
"set"                   { return SET;            }
"setdefaulttool"        { return SETDEFAULTTOOL; }
"setmedia"              { return SETMEDIA;       }
"setstack"              { return SETSTACK;       }
"settooltype"           { return SETTOOLTYPE;    }
"setposition"           { return SETPOSITION;    }
"shiftleft"             { return SHIFTLEFT;      }
"shiftright"            { return SHIFTRIGHT;     }
"showmedia"             { return SHOWMEDIA;      }
"showwbobject"          { return SHOWWBOBJECT;   }
"source"                { return SOURCE;         }
"startup"               { return STARTUP;        }
"strlen"                { return STRLEN;         }
"substr"                { return SUBSTR;         }
"swapcolors"            { return SWAPCOLORS;     }
"symbolset"             { return SYMBOLSET;      }
"symbolval"             { return SYMBOLVAL;      }
"tackon"                { return TACKON;         }
"textfile"              { return TEXTFILE;       }
"tooltype"              { return TOOLTYPE;       }
"trace"                 { return TRACE;          }
"transcript"            { return TRANSCRIPT;     }
"trap"                  { return TRAP;           }
"unix"                  { return UNIX;           }
"until"                 { return UNTIL;          }
"user"                  { return USER;           }
"welcome"               { return WELCOME;        }
"while"                 { return WHILE;          }
"working"               { return WORKING;        }
"xor"                   { return XOR;            }
"___astraw"             { return ASTRAW;         }
"___asbraw"             { return ASBRAW;         }
"___asbeval"            { return ASBEVAL;        }
"___eval"               { return EVAL;           }
"___options"            { return OPTIONS;        }

    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
    /* Strings                                                                                                                                                                          */
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
\"(\\.|[\\$]|[^"\\])*\"         |
'(\\.|[\\$]|[^'\\])*'           {
    yylval->s = strduptr(yytext);
    return yylval->s ? STR : OOM;
}

    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
    /* Symbols                                                                                                                                                                          */
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
[^"' ;\r\n\t\(\)\+\*/]+\+?[^"' ;\r\n\t\(\)]+?  {
    yylval->s = DBG_ALLOC(strdup(yytext));
    return yylval->s ? SYM : OOM;
}

    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
    /* The bottom feeders - Amiga / Unix, Windows and MacOS <= V9 support                                                                                                               */
    /*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
\\?[\t ]*\r\n           { yylineno++;                                   }
\\?[\t ]*\n             { yylineno++;                                   }
\\?[\t ]*\r             { yylineno++;                                   }
[\t ]+                  {                                               }
;                       { BEGIN(comment);                               }
<comment>\r\n           { BEGIN(INITIAL); yylineno++;                   }
<comment>\n             { BEGIN(INITIAL); yylineno++;                   }
<comment>\r             { BEGIN(INITIAL); yylineno++;                   }
<comment>.              {                                               }
<<EOF>>                 { fclose(script); script = NULL; yyterminate(); }
%%

/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* yyerror                                                                                                                                                                              */
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
int yyerror(yyscan_t scanner, const char *err)
{
    // Get line number and error info.
    int line = yyget_lineno(scanner);
    const char *info = yyget_text(scanner);

    // Print to stderr if we're executing from shell, show dialogue if we're
    // executing from WB.
    if(arg_argc(-1))
    {
        // All details to stderr.
        fprintf(stderr, tr(S_SYNT), line, err, info);
    }
    else
    {
        // Less details in the GUI.
        error(NULL, line, ERR_PARSE, err);
    }

    // Return a bogus value, not the number of bytes printed, like the default
    // yyerror function.
    return line;
}

/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* Main                                                                                                                                                                                 */
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
int main(int argc, char **argv)
{
    // Assume failure.
    int ret = -1;

#ifdef __AXRT__
    (void) argc;
    (void) argv;

    // Temp AxRT workaround until argument handling in AxRT is implemented.
    char *argv_[] = {"Installer", "axrt.script", NULL};

    if(arg_init(2, argv_))
#else
    // Initialize the argument handling.
    if(arg_init(argc, argv))
#endif
    {
        yyscan_t lexer;

        // Allocate and initialize reentrant lexer.
        if(yylex_init(&lexer) == 0)
        {
            // Get script name from CLI or tooltypes / WB.
            char *name = arg_get(ARG_SCRIPT);
            script = fopen(name, "r");

            // Disable stderr buffering (VBCC quirk).
            setvbuf(stderr, NULL, _IONBF, 0);

            if(script)
            {
                // Set input file and parse.
                yyset_in(script, lexer);

                // 1 on syntax error, 0 on success.
                ret = yyparse(lexer);

                #ifndef AMIGA
                (void) ret;
                #endif

                // Input is still open if the parser returns before EOF.
                if(script)
                {
                    fclose(script);
                }
            }
            else
            {
                // We can't read from the file.
                fprintf(stderr, tr(S_CNOF), name);
            }

            // Free all resources allocated by the lexer.
            yylex_destroy(lexer);
        }
        else
        {
            // We most likely ran out of memory.
            fprintf(stderr, "%s\n", tr(S_UNER));
        }
    }

    // Free all resources allocated by the argument handling routines.
    // This must be done even if arg_init() fails.
    arg_done();
#ifdef AMIGA
    // Translate value of ret to the appropriate Amiga DOS return value. Syntax
    // error is an ERROR and file not found / readable a FAIL.
    return (!ret ? ret : (ret == 1 ? RETURN_ERROR : RETURN_FAIL));
#else
    // Ignore errors on non Amiga systems.
    return 0;
#endif
}

/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* is_hex(const char *str) - Used by strduptr() to match hexadecimal escape sequences.                                                                                                          */
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
static inline bool is_hex(const char* str)
{
    return str[0] == 'x' &&
        (((str[1] >= 48 && str[1] <= 57) ||
          (str[1] >= 65 && str[1] <= 70) ||
          (str[1] >= 97 && str[1] <= 102)) &&
         ((str[2] >= 48 && str[2] <= 57) ||
          (str[2] >= 65 && str[2] <= 70) ||
          (str[2] >= 97 && str[2] <= 102)));
}

/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* is_oct(const char *str) - Used by strduptr() to match octal escape sequences.                                                                                                          */
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
static inline bool is_oct(const char* str)
{
    return str[0] >= 48 && str[0] <= 55 &&
           str[1] >= 48 && str[1] <= 55 &&
           str[2] >= 48 && str[2] <= 55;
}

/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* strduptr(const char *str) - Duplicate string and translate escape sequences according to Installer.guide 1.19 (29.4.96)                                                         */
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* `\n' newline character                                                                                                                                                               */
/* `\r' return character                                                                                                                                                                */
/* `\t' tab character                                                                                                                                                                   */
/* `\h' horizontal tab character (V42.6)                                                                                                                                                */
/* `\v' vertical tab character (V42.6)                                                                                                                                                  */
/* `\b' backspace character (V42.6)                                                                                                                                                     */
/* `\f' formfeed character (V42.6)                                                                                                                                                      */
/* `\"' double quote                                                                                                                                                                    */
/* `\'' single quote                                                                                                                                                                    */
/* `\\' backslash                                                                                                                                                                       */
/* `\ooo' some octal number `ooo' (V42.6)                                                                                                                                               */
/* `\xXX' some hex number `XX' (V42.6)                                                                                                                                                  */
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
static char *strduptr(const char *str)
{
    size_t len = strlen(str), io = 0;

    // No need to allocate room for delimiters.
    char *out = DBG_ALLOC(calloc(len - 1, 1));

    LG_ASSERT(out, NULL);

    // Using index 1 .. n - 1 to strip delimiters.
    for(size_t i = 1; i < len - 1; i++)
    {
        // Straight copy of non-escaped characters.
        if(str[i] != '\\' || (i + 1 >= len - 1))
        {
            out[io++] = str[i];
            continue;
        }

        // Escape character. Skip '\'.
        i++;

        // Room for an oct or hex escape sequence?
        if(i + 2 < len - 1)
        {
            if(is_hex(str + i))
            {
                // Translate hexadecimal number.
                char hex[] = { str[i + 1], str[i + 2], '\0' };
                out[io++] = (char) strtol(hex, NULL, 16);
                i += 2;
                continue;
            }

            if(is_oct(str + i))
            {
                // Translate octal number.
                char oct[] = { str[i], str[i + 1], str[i + 2], '\0' };
                out[io++] = (char) strtol(oct, NULL, 8);
                i += 2;
                continue;
            }
        }

        // Standard escape sequence mappings.
        char chr[] = "0nrthvbf\"'\\\0", raw[] = "\0\n\r\t\t\v\b\f\"'\\\0";

        for(size_t j = 0; chr[j];)
        {
            if(str[i] == chr[j])
            {
                // Translate.
                out[io++] = raw[j];
                break;
            }

            if(!chr[++j])
            {
                // No mapping.
                out[io++] = str[i];
            }
        }
    }

    return out;
}

/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#endif // #ifndef __clang_analyzer__
/*--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
